# 数据结构和算法

## 数据结构

对计算机内存中的数据的安排

## 算法

对结构中的数据的进行各种处理

## 常见应用

现实世界的数据存储

程序员的工具

现实世界的建模

## 常用数据结构的优缺点

| 数据结构          | 优点                                 | 缺点                             |
| ----------------- | ------------------------------------ | -------------------------------- |
| 数组              | 插入快（知道下标）                   | 查找、删除慢，大小固定           |
| 有序数组          | 比无序数组查找快                     | 插入、删除慢(需要排序)，大小固定 |
| 栈                | 提供后进先出存取方式                 | 存取其它项慢                     |
| 队列              | 提供先进先出存取方式                 | 存取其它项慢                     |
| 链表              | 插入、删除快                         | 查找慢                           |
| 二叉树            | 插入、查找、删除快（树平衡的情况下） | 算法复杂                         |
| 红黑树（平衡树）  | 插入、查找、删除快                   | 算法复杂                         |
| 2-3-4树（平衡树） | 插入、查找、删除快                   | 算法复杂                         |
| 哈希表            | 插入快，通过关键字存取快             | 删除慢                           |
| 堆                | 插入、查找慢，对最大数据项的存取快   | 存取其它项慢                     |
| 图                | 对现实世界的建模                     | 有些算法慢且复杂                 |
|                   |                                      |                                  |

## 涉及到的术语

数据库

记录

字段

关键字

## **Java Program Structure**

### class类

对象的模型

public class 类名{

}

对象：类的实例（方法和变量）

### main method

```java
public class SimpleAddition {

    public static void main(String[] args) {
        int a = 10;
        int b = 5;
        double c = a + b;
        System.out.println( a + " + " + b + " = " + c);
    }
}
```

### **Compiling and Executing a Program**

`javac SimpleAddition.java`

`java SimpleAddition`

## 常见数据类型

存在栈里

Let's start with a quick reference:

|   Type    | Size (bits) | Minimum |     Maximum      |             Example             |
| :-------: | ----------- | :-----: | :--------------: | :-----------------------------: |
|  *byte*   | 8           |  -2^7   |      2^7– 1      |         *byte b = 100;*         |
|  *short*  | 16          |  -2^15  |     2^15– 1      |       *short s = 30_000;*       |
|   *int*   | 32          |  -2^31  |     2^31– 1      |     *int i = 100_000_000;*      |
|  *long*   | 64          |  -2^63  |     2^63– 1      | *long l = 100_000_000_000_000;* |
|  *float*  | 32          | -2^-149 | (2-2^-23)·2^127  |       *float f = 1.456f;*       |
| *double*  | 64          | -2-1074 | (2-2^-52)·2^1023 | *double f = 1.456789012345678;* |
|  *char*   | 16          |    0    |     2^16– 1      |         *char c = ‘c';*         |
| *boolean* | 1           |    –    |        –         |       *boolean b = true;*       |

# 有序数组和二分查找

1、有序数组二分查找比较次数
数据量                 所需比较次数
10                    4
100                   7
1000                  10
10000                 14
100000                17
1000000               20
10000000              24
100000000             17
1000000000            30


2、有序数组优点：查找数据比无序数组快多了
缺点：插入时要按排序方式把后面的数据进行移动

有序数组和无序数组共同的缺点：删除时数据项时必须把后面的数据向前移动来填补



## 大O表示法

大O表示法

　　O(1)：优秀。例如无序数组插入。

　　O(logN)：良好。例如有序的二分查找。

　　O(N):及格。例如无序数组的删除，有序数组的删除和插入，线性查找。

　　O(N2):不及格。例如冒泡排序。

总结有序数组和无序数组

　　有序数组：插入+ 查找 +删除 = O(N) +O(logN)+O(N);

　　无序数组：插入 + 查找 + 删除 = O(1) + O(N) + O(N);

　　所以在数据偏向查找操作的时候用有序数组快一些，在数据偏向插入的时候，无序数组好一些。删除操作效率一样。

# java面向对象的冒泡排序，选择排序和插入排序的比较

这三种排序有俩个过程：

　　1.比较俩个数据。                   

　　2.交换俩个数据或复制其中一项。

这三种排序的时间级别

　　冒泡排序：比较 （N-1)+(N-2)+...+2+1 = N*(N-1)/2=N2/2

　　　　　　　交换 0——N2/2 = N2/4

　　　　　　　总时间 3/4*N2

　　选择排序：比较 （N-1)+(N-2)+...+2+1 = N*(N-1)/2=N2/2

　　　　　　　交换 0——3*（N-1）=3*（N-1）/2=3/2*N

　　　　　　　总时间 N2/2+3/2*N

　　插入排序：第一轮最多比较一次，第二轮最多比较俩次，最后一轮比较N-1次，所以最多比较N*(N-1)/2。

　　　　　　　复制的次数和比较的次数大致相等，但是复制消耗的时间比交换要小.

　　　　　　　比较 0——N*(N-1)/2=N*(N-1)/4=N2/4

　　　　　　　复制 0——N*(N-1)/2=N*(N-1)/4=N2/4

　　　　　　　总时间 N2//2

　　总结：插入排序算法比冒泡快一倍，比选择排序略快一点，但这些算法都是O(N2)的时间级别。

　　

这三种排序的思想　　

　　冒泡排序：在首轮，第一项和第二项比较，将大的放在后面，然后比较第二项和第三项，将大的放在后面，以此类推在首轮结束，最大的数据已经在最后一项了。在一轮轮的比较中，后面的已经排好的数据项越来越多，需要排序的数据项越来越少，直到为零。

　　选择排序：在冒泡排序上做了优化，减少了交换次数，在首轮选择最小的数放在第一项，一轮之后第一项是有序的了，第二轮从第二项开始选择最小的数放在第二项，以此类推，直到整个数组完全有序。

　　插入排序：和前俩种排序不同，插入排序在排序过程中是局部有序，随着插入项的增多，有序部分的项的位置会发生改变，而冒泡排序和选择排序每轮确定的项数的位置是永远不变的。在首轮，选择第二项作为插入项，然后取出这一项放在一个变量中，和前一项比较而且小，则前一项后移到第二项的位置，然后第二项也就是插入项放在前一项的位置，第二轮选择第三项作为插入项然后取出和前一项也就是第二项比较如果小，第二项后移到插入项，然后插入相在和第一项比较如果小，则第一项后移到第二项，插入项放在第一项，以此类推。

# 栈和栈的应用

数组 链表 树 适应于数据库应用中作数据记录

栈和队列
1、通常情况作为程序员的工具来运用
2、受限访问
3、更加抽象（主要通过接口进行定义）


栈就是一组记录，表现形式为先进后出

栈的应用
1、单词逆序
2、分隔符匹配

## 栈的应用：解析算术表达式

栈：先进后出
中缀表达式： A+B*C
后缀表达式：ABC*+

![img](doc\img\1554740-20190313144745221-676388967.png)

![img](doc\img\1554740-20190313144904426-1772349175.png)

# 队列和优先级队列

栈、 队列、 有序队列数据结构的生命周期比那些数据库类型的结构(比如链表，树)要短得多。在程序操作执行期间他们才被创建，通常用他们去执行某项特殊的任务；当完成任务之后，他们就会被销毁。这三个数据结构还有一个特点就是访问是受到限制的，即在特定时刻只有一个数据项可以被读取或者被删除，但是所谓的移除并不是真的删除，数据项依然在这些数据结构中，只不过因为指针已经指向其他数据项，没有办法访问到，当添加新的数据项时，当初移除的数据项被替代从而永远消失。



栈 队列 优先级队列的模拟思想

　　1.栈：栈遵循先进后出(FILO)模式最后插入的数据项最先被移除，而且只能访问最后的数据项，只有当移除这个数据项之后才能访问倒数第二项的数据项。

　　2.队列：队列遵循先进先出(FIFO)模式首先被插入的数据项最先被移除，而且只能访问访问第一个数据项，只有当移除这个数据项之后才能访问第二项的数据项。

　　3.优先级队列：优先级队列和队列的特性相同有队头和队尾，除此之外在优先级队列中，数据项按关键字的值有序，这样关键字最小的数据项或最大的数据项(视情况而定)总是在队头，数据项插入的时候会按照顺序插入到合适的位置以确保队列的顺序。



栈 队列 优先级队列的效率

　　栈：插入操作需要O(1),删除操作需要O(1)。

　　队列：插入操作需要O(1),删除操作需要O(1)。

　　优先级队列：插入操作需要O(N),删除操作需要O(1)。

队列的示例代码：

　　栈：top= -1。
　　队列：rear = -1， front = 0。
　　优先级队列：nItems = 0。

# 单链表

![image-20210206183308875](doc\img\image-20210206183308875.png)

双端链表

![image-20210206183512824](doc\img\image-20210206183512824.png)

# 用链表实现抽象数据类型

数据类型：任何一个类都是一种数据类型

当一个数据存储结构表示为一个类的情况下，这个类也就成为一个数据类型

抽象就是不考虑细节的描述和实现

栈和队列就是抽象数据类型

栈的特点：先进后出

队列的特点：先进先出

抽象数据类型：ADT



# 参考资料：

[operators in the Java language](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html)

