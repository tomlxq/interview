12.【最大括号深度】
现有一字符串仅由( , ) , { , } , [ , ]六种括号组成。若字符串满足以下条件之一，则为无效字符串：
1、任一类型的左右括号数量不相等；
2、存在未按正确顺序（先左后右）闭合的括号。

输出括号的最大嵌套深度，若字符串无效则输出0.
0<=字符串长度<=100000

输入描述：
一个只包( , ) , { , } , [ , ]的字符串。

输出描述:
一个整数，最大括号深度

示例1：
输入:[]
输出:1

解题思想：

①遍历字串，遇到`({[`入栈，遇到`]})`出栈

②出栈时，计算比较最大栈长度，与当前的字符组成f{open_char}{cur} 看是否是一对，否则为0

③完成后，判断栈是否为空，不为空依然为0



```java
public class MaxBracketNum {
    public int func(String line) {
        Stack<Character> stackOpen = new Stack<>();
        Stack<Character> stackClose = new Stack<>();
        Map<Character, Character> map = new HashMap<>();
        map.put('(', ')');
        map.put('{', '}');
        map.put('[', ']');
        int max = 0;
        for (char c : line.toCharArray()) {
            if (map.containsKey(c)) {
                stackOpen.add(c);
                stackClose.add(map.get(c));
            } else if (!stackOpen.isEmpty() && stackClose.contains(c)) {
                int size = stackClose.size();
                max = Math.max(size, max);
                char c1 = stackOpen.pop();
                char c2 = stackClose.pop();
                if (c != c2) {
                    max = 0;
                    break;
                }
            }
        }
        if (stackOpen.size() > 0) {
            max = 0;
        }
        return max;
    }
}
```

```python
class MaxBracketNum:
    def func(self, line: str) -> int:
        brackets = {"{": "}", "[": "]", "(": ")"}
        stacks_open = []
        stacks_close = []
        res = 0
        for c in line:
            if c in brackets.keys():
                stacks_open.append(c)
                stacks_close.append(brackets.get(c))
            else:
                if not stacks_open:
                    return res
                if c in brackets.values():
                    res = max(res, len(stacks_open))
                    c1 = stacks_open.pop()
                    c2 = stacks_close.pop()
                    if c != c2 or f"{c1}{c2}" not in ["[]", "{}", "()"]:
                        return 0
        else:
            if len(stacks_open) > 0:
                return 0
        return res


while 1:
    try:
        nums = input()
        max_ = 0
        stack = []
        for c in nums:
            if c in "{[(":
                stack.append(c)
            elif c in "]})":
                max_ = max(max_, len(stack))
                cr = stack.pop()
                if f"{cr}{c}" not in ["[]", "{}", "()"]:
                    max_ = 0
                    break
        else:  # break 不执行
            if len(stack) > 0:
                max_ = 0
        print(max_)
    except Exception as e:
        break
```

