14.【单词接龙】
题目描述：

单词接龙的规则是：

用于接龙的单词首字母必须要前一个单词的尾字母相同；
当存在多个首字母相同的单词时，取长度最长的单词，如果长度也相等，则取字典序最小的单词；
已经参与接龙的单词不能重复使用。
现给定一组全部由小写字母组成单词数组，并指定其中的一个单词作为起始单词，进行单词接龙。

请输出最长的单词串，单词串是单词拼接而成，中间没有空格。

输入描述：

输入的第一行为一个非负整数，表示起始单词在数组中的索引K，0 <= K < N。
输入的第二行为一个非负整数，表示单词的个数N。
接下来的N行，分别表示单词数组中的单词。
输出描述：

输出一个字符串，表示最终拼接的单词串。
备注：

单词个数N的取值范围为[1, 20]
单个单词的长度的取值范围为[1, 30]

解题思路:

①对输入的单词放到列表list1中

②准备输出单词列表dp，取出起始单词放在dp中，并从list1移走

③循环list1，准备缓存列表cache,判断所有单词首字母与dp中最后一词的尾字母相同的词放入cache

④当cache存，则对cache排序，按字母长度，最长排最前，然后按字母排，取排好序的第一个单词存到dp中，同时从list1移走

⑤最后将dp所有单词连接成字串返回

```java

import java.util.*;
import java.util.stream.Collectors;

public class ConcatWord {
    public String func(int num, String line) {
        List<String> ary = Arrays.stream(line.split("\\s+")).collect(Collectors.toList());
        List<String> dp = new ArrayList<String>();
        dp.add(ary.get(num));
        ary.remove(ary.get(num));
        while (ary.size() > 0) {
            List<String> cache = new ArrayList<String>();
            for (String w : ary) {
                String last = dp.get(dp.size() - 1);
                if (w.charAt(0) == last.charAt(last.length() - 1)) {
                    cache.add(w);
                }
            }
            if (cache.size() > 0) {
                Collections.sort(cache, (a, b) -> b.length() == a.length() ? a.compareTo(b) : b.length() - a.length());
                dp.add(cache.get(0));
                ary.remove(cache.get(0));
            } else {
                break;
            }
        }
        return dp.stream().collect(Collectors.joining());
    }

    public static void main(String[] args) {
        //"worddwordda", 0,6,"word dd da dc dword d"
        try (Scanner sc = new Scanner(System.in)) {
            int idx = sc.nextInt();
            int n = sc.nextInt();
            List<String> list = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                list.add(sc.next());
            }
            ConcatWord cw = new ConcatWord();
            System.out.println(cw.func(idx, list.stream().collect(Collectors.joining(" "))));
        }
    }
}
```



```python
class ConcatWord:
    def func(self, idx: int, line: str) -> str:
        list1 = line.split(" ")
        dp = []
        dp.append(list1.pop(idx))
        while len(list1):
            cache = []
            for w in list1:
                # 当前单词的首字母==最后一个单词的尾字母
                if w[0] == dp[-1][-1]:
                    cache.append(w)
            if cache:
                # 符合条件的单词排序 最长的长度排最前面，其次按字母排序
                cache = sorted(cache, key=lambda x: (-len(x), x))
                dp.append(cache[0])
                list1.remove(cache[0])
            else:
                break
        return ''.join(dp)


while True:
    try:
        # "worddwordda", 0,6,"word dd da dc dword d"
        idx = int(input())
        num = int(input())
        ary = [input() for _ in range(num)]
        cw = ConcatWord()
        print(cw.func(idx, ' '.join(ary)))
    except Exception as e:
        break
```

