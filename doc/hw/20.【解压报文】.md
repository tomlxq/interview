20.【解压报文】
题目描述：
解压报文 | 时间限制：1秒 | 内存限制：262144K | 语言限制：不限
为了提升数据传输的效率，会对传输的报文进行压缩处理。输入一个压缩后的报文，请返回它解压后的原始报文。
压缩规则：n[str]，表示方括号内部的 str 正好重复 n 次。注意 n 为正整数（0 < n <= 100），str只包含小写英文字母，不考虑异常情况。
" “输入描述:
输入压缩后的报文：
1）不考虑无效的输入，报文没有额外的空格，方括号总是符合格式要求的；
2）原始报文不包含数字，所有的数字只表示重复的次数 n ，例如不会出现像 5b 或 3[8] 的输入；
输出描述:
解压后的原始报文
注：
1）原始报文长度不会超过1000，不考虑异常的情况
示例1
输入
3[k]2[mn]
输出
kkkmnmn
说明
k 重复3次，mn 重复2次，最终得到 kkkmnmn
示例2
输入
3[m2[c]]
输出
mccmccmcc
说明
m2[c] 解压缩后为 mcc，重复三次为 mccmccmcc”

解题思路：采用递归

```java
public class DecompressPacket {

    public String func(String line) {
        if (line.equals("") || !line.contains("[")) {
            if (line.equals("]")) {
                return "";
            }
            return line;
        }
        int openIdx = line.indexOf('[');
        int closeIdx = line.indexOf(']');
        int num = Integer.parseInt(line.substring(0, openIdx));
        String str = line.substring(openIdx + 1, closeIdx);
        StringBuffer sb = new StringBuffer();
        if (!str.contains("[")) {
            String collect = IntStream.range(0, num).mapToObj(i -> func(str)).collect(Collectors.joining());
            sb.append(collect);
            sb.append(func(line.substring(closeIdx + 1)));
        } else {
            int len = str.length() - str.replaceAll("\\[", "").length() + 1;
            int lastIdx = closeIdx;
            while (len > 0) {
                if ((lastIdx = line.indexOf(']')) != -1) {
                    len--;
                }
            }
            num = Integer.parseInt(line.substring(0, openIdx));
            String str2 = line.substring(openIdx + 1, lastIdx + 1);
            int k = 0;
            while (Character.isAlphabetic(str2.charAt(k))) {
                k++;
            }
            String preStr = str2.substring(0, k);
            String suffixStr = str2.substring(k);
            String collect = IntStream.range(0, num).mapToObj(i -> preStr + func(suffixStr)).collect(Collectors.joining());
            sb.append(collect);
            sb.append(func(line.substring(closeIdx + 1)));
        }
        return sb.toString();
    }
}
```

```python
class DecompressPacket:
    def func(self, line: str) -> str:
        def process(line: str):
            if line == '' or line.find('[') == -1:
                if line == ']':
                    return ''
                return line
            open_idx = line.find('[')
            close_idx = line.find(']')
            tmp = line[open_idx + 1:close_idx]
            num = int(line[0:open_idx])
            if tmp.find('[') == -1:
                return tmp * num + process(line[close_idx + 1:len(line)])
            else:
                n = tmp.count('[') + 1
                last_idx = close_idx
                while (last_idx := line.find(']')) != -1 and n > 0:
                    n -= 1
                close_idx = last_idx
                tmp = line[open_idx + 1:close_idx + 1]
                i, j = 0, 0
                for i in range(len(tmp)):
                    if tmp[i].isalpha():
                        continue
                    break
                pre_str = tmp[j:i]
                return (pre_str + process(tmp[i:len(tmp)])) * num
        return process(line)
```

