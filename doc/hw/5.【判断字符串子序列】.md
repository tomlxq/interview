5.【判断字符串子序列】
【判断字符串子序列】给定字符串target和source，判断target是否为source的子序列。你可以认为target和source 中仅包含英文小写字母，字符串source可能会很长，长度~=500,000，而target是个短字符串，长度<=100。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串，例如，'abc’是’aebycd’的一个子序列，而’ayb’不是。请找出最后一个序列的起始位置。
示例输入：
abc
abcaybec
示例输出：
3
因为aybec中的abc的a在整个字符串的位置索引是3

解题思路：

①直接采用搜索字符的方式定位置，返回定位的位置+搜索字串长度

②采用双指针， 分别由后往前遍历，当搜索字符为0时，表示搜索的字串存在，返回指针即可



```java
package com.tom.huawei;

public class StringDemo {
    public int findString(String search, String str) {
        int idx = str.lastIndexOf(search);
        if (idx == -1) {
            return idx;
        } else {
            return idx + search.length();
        }
    }

    public int findString2(String search, String str) {
        int fast = str.length() - 1, slow = search.length()-1;
        while (fast >= 0 && slow >= 0) {
            if (search.charAt(slow) == str.charAt(fast)) {
                if (slow == 0) {
                    return fast;
                }
                slow--;
            }
            fast--;
        }
        return -1;
    }
}
```

```python
class StringDemo:
    def findString(self, search: str, letters: str) -> int:
        idx = letters.rfind(search)
        if idx == -1:
            return idx
        else:
            return idx + len(search)

    def findString2(self, search: str, letters: str) -> int:
        fast, slow = len(letters) - 1, len(search) - 1
        while fast >= 0 and slow >= 0:
            if search[slow] == letters[fast]:
                if slow == 0:
                    return fast
                slow -= 1
            fast -= 1
        return -1
```

