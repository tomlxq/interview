22.【统计射击比赛成绩】
题目描述
给定一个射击比赛成绩单，包含多个选手若干次射击的成绩分数，请对每个选手按其最高3个分数之和进行降序排名，输出降序排名后的选手ID序列。

条件如下：

一个选手可以有多个射击成绩的分数，且次序不固定。
如果一个选手成绩少于3个，则认为选手的所有成绩无效，排名忽略该选手。
如果选手的成绩之和相等，则成绩之和相等的选手按照其ID降序排列。
输入描述:

输入第一行，一个整数N，表示该场比赛总共进行了N次射击，产生N个成绩分数（2<=N<=100）。
输入第二行，一个长度为N整数序列，表示参与每次射击的选手ID（0<=ID<=99）。
输入第三行，一个长度为N整数序列，表示参与每次射击的选手对应的成绩（0<=成绩<=100）。
输出描述:
符合题设条件的降序排名后的选手ID序列。

示例1
输入

13
3,3,7,4,4,4,4,7,7,3,5,5,5
53,80,68,24,39,76,66,16,100,55,53,80,55

输出

5,3,7,4
说明

该场射击比赛进行了13次，参赛的选手为{3,4,5,7}。 3号选手成绩：
53,80,55，最高3个成绩的和为：80+55+53=188。
4号选手成绩：24,39,76,66，最高3个成绩的和为：76+66+39=181。
5号选手成绩：53,80,55，最高3个成绩的和为：80+55+53=188。
7号选手成绩：68,16,100，最高3个成绩的和为：100+68+16=184。
比较各个选手最高3个成绩的和，有3号=5号>7号>4号，由于3号和5号成绩相等且ID号5>3， 所以输出为：5,3,7,4

```python
class ShootingScore:
    def func(self, times: int, ids: str, scores: str) -> str:
        list_ids = ids.split(",")
        list_scores = list(map(int, scores.split(",")))
        data = {}
        for i in range(times):
            if list_ids[i] in data:
                data[list_ids[i]].append(list_scores[i])
            else:
                data[list_ids[i]] = [list_scores[i]]
        for k, v in data.items():
            if len(v) < 3:
                data.pop(k)
            else:
                v.sort(reverse=True)
                data[k] = sum(v[:3])
        res = sorted(data.items(), key=lambda x: (x[1], x[0]), reverse=True)
        return ','.join(k for k, v in res)
```

```java
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
public class ShootingScore {
    public String func(int times, String ids, String scores) {
        String[] aryIds = ids.split(",");
        int[] aryScores = Arrays.stream(scores.split(",")).mapToInt(Integer::parseInt).toArray();
        Map<String, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < times; i++) {
            List<Integer> list = map.getOrDefault(aryIds[i], new ArrayList<Integer>());
            list.add(aryScores[i]);
            map.put(aryIds[i], list);
        }
        ArrayList<Map.Entry<String, List<Integer>>> entries = new ArrayList<>(map.entrySet());
        Map<String, Integer> sorted = new HashMap<>();
        for (Map.Entry<String, List<Integer>> entry : entries) {
            List<Integer> value = entry.getValue();
            if (value.size() > 2) {
                Collections.sort(value);
                Collections.reverse(value);
                sorted.put(entry.getKey(), IntStream.range(0, 3).map(i -> i < value.size() && i < 3 ? value.get(i) : 0).sum());
            }
        }
        List<Map.Entry<String, Integer>> entries2 = new ArrayList<>(sorted
                .entrySet());
        Collections.sort(entries2, (e1, e2) -> e1.getValue().compareTo(e2.getValue()) == 0 ? e1.getKey().compareTo(e2.getKey()) : e1.getValue().compareTo(e2.getValue()));
        Collections.reverse(entries2);
        return entries2.stream().map(i -> i.getKey()).collect(Collectors.joining(","));
    }
}
```



