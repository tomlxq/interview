8.【最长方连续方波信号】
【最长方连续方波信号】最长方连续方波信号 | 时间限制：1秒 | 内存限制：262144K | 语言限制：不限
输入一串方波信号，求取最长的完全连续交替方波信号，并将其输出，如果有相同长度的交替方波信号，输出任一即可，方波信号高位用1标识，低位用0标识，如图：
说明：
1） 一个完整的信号一定以0开始然后以0结尾，即010是一个完整信号，但101，1010，0101不是
2）输入的一串方波信号是由一个或多个完整信号组成
3） 两个相邻信号之间可能有0个或多个低位，如0110010，011000010
4） 同一个信号中可以有连续的高位，如01110101011110001010，前14位是一个具有连续高位的信号
5） 完全连续交替方波是指10交替，如01010是完全连续交替方波，0110不是
 输入描述: 输入信号字符串（长度>=3且<=1024）： 0010101010110000101000010 注：输入总是合法的，不用考虑异常情况
输出描述: 输出最长的完全连续交替方波信号串： 01010 若不存在完全连续交替方波信号串，输出 -1

示例1
输入
00101010101100001010010
输出
01010
备注:
输入信号串中有三个信号：0 010101010110(第一个信号段) 00 01010(第二个信号段) 010(第三个信号段)
第一个信号虽然有交替的方波信号段，但出现了11部分的连续高位，不算完全连续交替方波，在剩下的连续方波信号串中01010最长

 解题思路：

①返回字串s初始值为-1

②遍历字串，当前字符为0，而且缓存数组 List<Character> cache的最后一个字符为0

则把当前cache中的字符数组组成字串line3

判断不包括11，则把当前字串长度line3与max比较，取最大值。

若最大值与字串长度line3相同，则把返回字串s赋值为当前字串

把cache初始化为[0]

否则 cache 累增0

③完成处理后返回s

```java
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;


public class MaxSignDemo {
    public String func(String line) {
        List<Character> cache = new ArrayList<Character>();
        int max = 0;
        String s = "-1";
        for (char read : line.toCharArray()) {
            if (cache.size() > 0 && cache.get(cache.size() - 1) == '0' && read == '0') {
                String line3 = cache.stream().map(String::valueOf).collect(Collectors.joining());
                if (!line3.contains("11")) {
                    max = Math.max(max, line3.length());
                    if (max == line3.length()) {
                        s = line3;
                    }
                }
                cache.clear();
                cache.add(read);
            } else {
                cache.add(read);
            }
        }
        return s;
    }
}
```





```python
class MaxSignDemo:
    def func(self, line: str) -> str:
        max_len = 0
        s = "-1"
        cache = []
        for c in line:
            if cache and cache[-1] == c == '0':
                line2 = ''.join(cache)
                if "11" not in line2:
                    max_len = max(max_len, len(line2))
                    if max_len == len(line2):
                        s = line2
                cache = [c]
            else:
                cache.append(c)
        return s


while True:
    try:
        msd = MaxSignDemo()
        print(msd.func(input()))
    except Exception as e:
        break
```





